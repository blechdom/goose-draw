{"ast":null,"code":"import _toConsumableArray from \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/src/RCD.js\";\nimport React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { LazyBrush } from \"lazy-brush\";\nimport { Catenary } from \"catenary-curve\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nimport drawImage from \"./drawImage\";\n\nfunction midPointBtw(p1, p2) {\n  return {\n    x: p1.x + (p2.x - p1.x) / 2,\n    y: p1.y + (p2.y - p1.y) / 2\n  };\n}\n\nvar canvasStyle = {\n  display: \"block\",\n  position: \"absolute\"\n};\nvar canvasTypes = [{\n  name: \"interface\",\n  zIndex: 15\n}, {\n  name: \"drawing\",\n  zIndex: 11\n}, {\n  name: \"temp\",\n  zIndex: 12\n}, {\n  name: \"grid\",\n  zIndex: 10\n}];\n\nvar _default =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(_default, _PureComponent);\n\n  function _default(props) {\n    var _this;\n\n    _classCallCheck(this, _default);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_default).call(this, props));\n\n    _this.componentWillUnmount = function () {\n      _this.canvasObserver.unobserve(_this.canvasContainer);\n    };\n\n    _this.drawImage = function () {\n      if (!_this.props.imgSrc) return; // Load the image\n\n      _this.image = new Image();\n      _this.image.src = _this.props.imgSrc; // Draw the image once loaded\n\n      _this.image.onload = function () {\n        return drawImage({\n          ctx: _this.ctx.grid,\n          img: _this.image\n        });\n      };\n    };\n\n    _this.undo = function () {\n      var lines = _this.lines.slice(0, -1);\n\n      _this.clear();\n\n      _this.simulateDrawingLines({\n        lines: lines,\n        immediate: true\n      });\n    };\n\n    _this.getSaveData = function () {\n      // Construct and return the stringified saveData object\n      return JSON.stringify({\n        lines: _this.lines,\n        width: _this.props.canvasWidth,\n        height: _this.props.canvasHeight\n      });\n    };\n\n    _this.loadSaveData = function (saveData) {\n      var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.props.immediateLoading;\n      console.log(\"save data \", saveData);\n\n      if (typeof saveData !== \"string\") {\n        throw new Error(\"saveData needs to be of type string!\");\n      }\n\n      var _JSON$parse = JSON.parse(saveData),\n          lines = _JSON$parse.lines,\n          width = _JSON$parse.width,\n          height = _JSON$parse.height;\n\n      if (!lines || typeof lines.push !== \"function\") {\n        throw new Error(\"saveData.lines needs to be an array!\");\n      }\n\n      _this.clear();\n\n      if (width === _this.props.canvasWidth && height === _this.props.canvasHeight) {\n        _this.simulateDrawingLines({\n          lines: lines,\n          immediate: immediate\n        });\n      } else {\n        // we need to rescale the lines based on saved & current dimensions\n        var scaleX = _this.props.canvasWidth / width;\n        var scaleY = _this.props.canvasHeight / height;\n        var scaleAvg = (scaleX + scaleY) / 2;\n\n        _this.simulateDrawingLines({\n          lines: lines.map(function (line) {\n            return _objectSpread({}, line, {\n              points: line.points.map(function (p) {\n                return {\n                  x: p.x * scaleX,\n                  y: p.y * scaleY\n                };\n              }),\n              brushRadius: line.brushRadius * scaleAvg\n            });\n          }),\n          immediate: immediate\n        });\n      }\n    };\n\n    _this.simulateDrawingLines = function (_ref) {\n      var lines = _ref.lines,\n          immediate = _ref.immediate;\n      // Simulate live-drawing of the loaded lines\n      // TODO use a generator\n      var curTime = 0;\n      var timeoutGap = immediate ? 0 : _this.props.loadTimeOffset;\n      lines.forEach(function (line) {\n        var points = line.points,\n            brushColor = line.brushColor,\n            brushRadius = line.brushRadius;\n\n        var _loop = function _loop(i) {\n          curTime += timeoutGap;\n          window.setTimeout(function () {\n            _this.drawPoints({\n              points: points.slice(0, i + 1),\n              brushColor: brushColor,\n              brushRadius: brushRadius\n            });\n          }, curTime);\n        };\n\n        for (var i = 1; i < points.length; i++) {\n          _loop(i);\n        }\n\n        curTime += timeoutGap;\n        window.setTimeout(function () {\n          // Save this line with its props instead of this.props\n          _this.points = points;\n\n          _this.saveLine({\n            brushColor: brushColor,\n            brushRadius: brushRadius\n          });\n        }, curTime);\n      });\n    };\n\n    _this.handleTouchStart = function (e) {\n      var _this$getPointerPos = _this.getPointerPos(e),\n          x = _this$getPointerPos.x,\n          y = _this$getPointerPos.y;\n\n      _this.lazy.update({\n        x: x,\n        y: y\n      }, {\n        both: true\n      });\n\n      _this.handleMouseDown(e);\n\n      _this.mouseHasMoved = true;\n    };\n\n    _this.handleTouchMove = function (e) {\n      e.preventDefault();\n\n      var _this$getPointerPos2 = _this.getPointerPos(e),\n          x = _this$getPointerPos2.x,\n          y = _this$getPointerPos2.y;\n\n      _this.handlePointerMove(x, y);\n    };\n\n    _this.handleTouchEnd = function (e) {\n      _this.handleMouseUp(e);\n\n      var brush = _this.lazy.getBrushCoordinates();\n\n      _this.lazy.update({\n        x: brush.x,\n        y: brush.y\n      }, {\n        both: true\n      });\n\n      _this.mouseHasMoved = true;\n    };\n\n    _this.handleMouseDown = function (e) {\n      e.preventDefault();\n      _this.isPressing = true;\n    };\n\n    _this.handleMouseMove = function (e) {\n      var _this$getPointerPos3 = _this.getPointerPos(e),\n          x = _this$getPointerPos3.x,\n          y = _this$getPointerPos3.y;\n\n      _this.handlePointerMove(x, y);\n    };\n\n    _this.handleMouseUp = function (e) {\n      e.preventDefault();\n      _this.isDrawing = false;\n      _this.isPressing = false;\n\n      _this.saveLine();\n    };\n\n    _this.handleCanvasResize = function (entries, observer) {\n      var saveData = _this.getSaveData();\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var entry = _step.value;\n          var _entry$contentRect = entry.contentRect,\n              width = _entry$contentRect.width,\n              height = _entry$contentRect.height;\n\n          _this.setCanvasSize(_this.canvas.interface, width, height);\n\n          _this.setCanvasSize(_this.canvas.drawing, width, height);\n\n          _this.setCanvasSize(_this.canvas.temp, width, height);\n\n          _this.setCanvasSize(_this.canvas.grid, width, height);\n\n          _this.drawGrid(_this.ctx.grid);\n\n          _this.loop({\n            once: true\n          });\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      _this.loadSaveData(saveData, true);\n    };\n\n    _this.setCanvasSize = function (canvas, width, height) {\n      canvas.width = width;\n      canvas.height = height;\n      canvas.style.width = width;\n      canvas.style.height = height;\n    };\n\n    _this.getPointerPos = function (e) {\n      var rect = _this.canvas.interface.getBoundingClientRect(); // use cursor pos as default\n\n\n      var clientX = e.clientX;\n      var clientY = e.clientY; // use first touch if available\n\n      if (e.changedTouches && e.changedTouches.length > 0) {\n        clientX = e.changedTouches[0].clientX;\n        clientY = e.changedTouches[0].clientY;\n      } // return mouse/touch position inside canvas\n\n\n      return {\n        x: clientX - rect.left,\n        y: clientY - rect.top\n      };\n    };\n\n    _this.handlePointerMove = function (x, y) {\n      if (_this.props.disabled) return;\n\n      var hasChanged = _this.lazy.update({\n        x: x,\n        y: y\n      });\n\n      var isDisabled = !_this.lazy.isEnabled();\n\n      if (_this.isPressing && hasChanged && !_this.isDrawing || isDisabled && _this.isPressing) {\n        // Start drawing and add point\n        _this.isDrawing = true;\n\n        _this.points.push(_this.lazy.brush.toObject());\n      }\n\n      if (_this.isDrawing && (_this.lazy.brushHasMoved() || isDisabled)) {\n        // Add new point\n        _this.points.push(_this.lazy.brush.toObject()); // Draw current points\n\n\n        _this.drawPoints({\n          points: _this.points,\n          brushColor: _this.props.brushColor,\n          brushRadius: _this.props.brushRadius\n        });\n      }\n\n      _this.mouseHasMoved = true;\n    };\n\n    _this.drawPoints = function (_ref2) {\n      var points = _ref2.points,\n          brushColor = _ref2.brushColor,\n          brushRadius = _ref2.brushRadius;\n      _this.ctx.temp.lineJoin = \"round\";\n      _this.ctx.temp.lineCap = \"round\";\n      _this.ctx.temp.strokeStyle = brushColor;\n\n      _this.ctx.temp.clearRect(0, 0, _this.ctx.temp.canvas.width, _this.ctx.temp.canvas.height);\n\n      _this.ctx.temp.lineWidth = brushRadius * 2;\n      var p1 = points[0];\n      var p2 = points[1];\n\n      _this.ctx.temp.moveTo(p2.x, p2.y);\n\n      _this.ctx.temp.beginPath();\n\n      for (var i = 1, len = points.length; i < len; i++) {\n        // we pick the point between pi+1 & pi+2 as the\n        // end point and p1 as our control point\n        var midPoint = midPointBtw(p1, p2);\n\n        _this.ctx.temp.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n\n        p1 = points[i];\n        p2 = points[i + 1];\n      } // Draw last line as a straight line while\n      // we wait for the next point to be able to calculate\n      // the bezier control point\n\n\n      _this.ctx.temp.lineTo(p1.x, p1.y);\n\n      _this.ctx.temp.stroke();\n    };\n\n    _this.saveLine2 = function (data) {\n      _this.isDrawing = false;\n      _this.isPressing = false;\n      console.log(\"data from saveline: \", data);\n      console.log(\"saveLine2 called\");\n\n      _this.lines.push(data);\n\n      console.log(\"lines: \", _this.lines);\n      _this.points.length = 0;\n      var width = _this.canvas.temp.width;\n      var height = _this.canvas.temp.height; // Copy the line to the drawing canvas\n\n      _this.ctx.drawing.drawImage(_this.canvas.temp, 0, 0, width, height); // Clear the temporary line-drawing canvas\n\n\n      _this.ctx.temp.clearRect(0, 0, width, height);\n    };\n\n    _this.saveLine = function () {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          brushColor = _ref3.brushColor,\n          brushRadius = _ref3.brushRadius;\n\n      if (_this.points.length < 2) return; // Save as new line\n\n      _this.lines.push({\n        points: _toConsumableArray(_this.points),\n        brushColor: brushColor || _this.props.brushColor,\n        brushRadius: brushRadius || _this.props.brushRadius\n      }); // Reset points array\n\n\n      _this.points.length = 0;\n      var width = _this.canvas.temp.width;\n      var height = _this.canvas.temp.height; // Copy the line to the drawing canvas\n\n      _this.ctx.drawing.drawImage(_this.canvas.temp, 0, 0, width, height); // Clear the temporary line-drawing canvas\n\n\n      _this.ctx.temp.clearRect(0, 0, width, height);\n    };\n\n    _this.clear = function () {\n      _this.lines = [];\n      _this.valuesChanged = true;\n\n      _this.ctx.drawing.clearRect(0, 0, _this.canvas.drawing.width, _this.canvas.drawing.height);\n\n      _this.ctx.temp.clearRect(0, 0, _this.canvas.temp.width, _this.canvas.temp.height);\n    };\n\n    _this.loop = function () {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$once = _ref4.once,\n          once = _ref4$once === void 0 ? false : _ref4$once;\n\n      if (_this.mouseHasMoved || _this.valuesChanged) {\n        var pointer = _this.lazy.getPointerCoordinates();\n\n        var brush = _this.lazy.getBrushCoordinates();\n\n        _this.drawInterface(_this.ctx.interface, pointer, brush);\n\n        _this.mouseHasMoved = false;\n        _this.valuesChanged = false;\n      }\n\n      if (!once) {\n        window.requestAnimationFrame(function () {\n          _this.loop();\n        });\n      }\n    };\n\n    _this.drawGrid = function (ctx) {\n      if (_this.props.hideGrid) return;\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.beginPath();\n      ctx.setLineDash([5, 1]);\n      ctx.setLineDash([]);\n      ctx.strokeStyle = _this.props.gridColor;\n      ctx.lineWidth = 0.5;\n      var gridSize = 25;\n      var countX = 0;\n\n      while (countX < ctx.canvas.width) {\n        countX += gridSize;\n        ctx.moveTo(countX, 0);\n        ctx.lineTo(countX, ctx.canvas.height);\n      }\n\n      ctx.stroke();\n      var countY = 0;\n\n      while (countY < ctx.canvas.height) {\n        countY += gridSize;\n        ctx.moveTo(0, countY);\n        ctx.lineTo(ctx.canvas.width, countY);\n      }\n\n      ctx.stroke();\n    };\n\n    _this.drawInterface = function (ctx, pointer, brush) {\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Draw brush preview\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.brushColor;\n      ctx.arc(brush.x, brush.y, _this.props.brushRadius, 0, Math.PI * 2, true);\n      ctx.fill(); // Draw mouse point (the one directly at the cursor)\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.catenaryColor;\n      ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI * 2, true);\n      ctx.fill(); // Draw catenary\n\n      if (_this.lazy.isEnabled()) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.lineCap = \"round\";\n        ctx.setLineDash([2, 4]);\n        ctx.strokeStyle = _this.props.catenaryColor;\n\n        _this.catenary.drawToCanvas(_this.ctx.interface, brush, pointer, _this.chainLength);\n\n        ctx.stroke();\n      } // Draw brush point (the one in the middle of the brush preview)\n\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.catenaryColor;\n      ctx.arc(brush.x, brush.y, 2, 0, Math.PI * 2, true);\n      ctx.fill();\n    };\n\n    _this.canvas = {};\n    _this.ctx = {};\n    _this.catenary = new Catenary();\n    _this.points = [];\n    _this.lines = [];\n    _this.mouseHasMoved = true;\n    _this.valuesChanged = true;\n    _this.isDrawing = false;\n    _this.isPressing = false;\n    return _this;\n  }\n\n  _createClass(_default, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      this.lazy = new LazyBrush({\n        radius: this.props.lazyRadius * window.devicePixelRatio,\n        enabled: true,\n        initialPoint: {\n          x: window.innerWidth / 2,\n          y: window.innerHeight / 2\n        }\n      });\n      this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n      this.canvasObserver = new ResizeObserver(function (entries, observer) {\n        return _this2.handleCanvasResize(entries, observer);\n      });\n      this.canvasObserver.observe(this.canvasContainer);\n      this.drawImage();\n      this.loop();\n      window.setTimeout(function () {\n        var initX = window.innerWidth / 2;\n        var initY = window.innerHeight / 2;\n\n        _this2.lazy.update({\n          x: initX - _this2.chainLength / 4,\n          y: initY\n        }, {\n          both: true\n        });\n\n        _this2.lazy.update({\n          x: initX + _this2.chainLength / 4,\n          y: initY\n        }, {\n          both: false\n        });\n\n        _this2.mouseHasMoved = true;\n        _this2.valuesChanged = true;\n\n        _this2.clear(); // Load saveData from prop if it exists\n\n\n        if (_this2.props.saveData) {\n          console.log;\n\n          _this2.loadSaveData(_this2.props.saveData);\n        }\n      }, 100);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.lazyRadius !== this.props.lazyRadius) {\n        // Set new lazyRadius values\n        this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n        this.lazy.setRadius(this.props.lazyRadius * window.devicePixelRatio);\n      }\n\n      if (prevProps.saveData !== this.props.saveData) {\n        this.loadSaveData(this.props.saveData);\n      }\n\n      if (JSON.stringify(prevProps) !== JSON.stringify(this.props)) {\n        // Signal this.loop function that values changed\n        this.valuesChanged = true;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      return React.createElement(\"div\", {\n        className: this.props.className,\n        style: _objectSpread({\n          display: \"block\",\n          background: \"#fff\",\n          touchAction: \"none\",\n          width: this.props.canvasWidth,\n          height: this.props.canvasHeight\n        }, this.props.style),\n        ref: function ref(container) {\n          if (container) {\n            _this3.canvasContainer = container;\n          }\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 543\n        },\n        __self: this\n      }, canvasTypes.map(function (_ref5) {\n        var name = _ref5.name,\n            zIndex = _ref5.zIndex;\n        var isInterface = name === \"interface\";\n        return React.createElement(\"canvas\", {\n          key: name,\n          ref: function ref(canvas) {\n            if (canvas) {\n              _this3.canvas[name] = canvas;\n              _this3.ctx[name] = canvas.getContext(\"2d\");\n            }\n          },\n          style: _objectSpread({}, canvasStyle, {\n            zIndex: zIndex\n          }),\n          onMouseDown: isInterface ? _this3.handleMouseDown : undefined,\n          onMouseMove: isInterface ? _this3.handleMouseMove : undefined,\n          onMouseUp: isInterface ? _this3.handleMouseUp : undefined,\n          onMouseOut: isInterface ? _this3.handleMouseUp : undefined,\n          onTouchStart: isInterface ? _this3.handleTouchStart : undefined,\n          onTouchMove: isInterface ? _this3.handleTouchMove : undefined,\n          onTouchEnd: isInterface ? _this3.handleTouchEnd : undefined,\n          onTouchCancel: isInterface ? _this3.handleTouchEnd : undefined,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 562\n          },\n          __self: this\n        });\n      }));\n    }\n  }]);\n\n  return _default;\n}(PureComponent);\n\n_default.propTypes = {\n  loadTimeOffset: PropTypes.number,\n  lazyRadius: PropTypes.number,\n  brushRadius: PropTypes.number,\n  brushColor: PropTypes.string,\n  catenaryColor: PropTypes.string,\n  gridColor: PropTypes.string,\n  hideGrid: PropTypes.bool,\n  canvasWidth: PropTypes.number,\n  canvasHeight: PropTypes.number,\n  disabled: PropTypes.bool,\n  imgSrc: PropTypes.string,\n  saveData: PropTypes.string,\n  immediateLoading: PropTypes.bool\n};\n_default.defaultProps = {\n  loadTimeOffset: 5,\n  lazyRadius: 12,\n  brushRadius: 10,\n  brushColor: \"#444\",\n  catenaryColor: \"#0a0302\",\n  gridColor: \"rgba(150,150,150,0.17)\",\n  hideGrid: false,\n  canvasWidth: 400,\n  canvasHeight: 400,\n  disabled: false,\n  imgSrc: \"\",\n  saveData: \"\",\n  immediateLoading: false\n};\nexport { _default as default };","map":{"version":3,"sources":["/home/blech/Dev/aws-amplify-appsync-graphql-real-time-canvas/src/RCD.js"],"names":["React","PureComponent","PropTypes","LazyBrush","Catenary","ResizeObserver","drawImage","midPointBtw","p1","p2","x","y","canvasStyle","display","position","canvasTypes","name","zIndex","props","componentWillUnmount","canvasObserver","unobserve","canvasContainer","imgSrc","image","Image","src","onload","ctx","grid","img","undo","lines","slice","clear","simulateDrawingLines","immediate","getSaveData","JSON","stringify","width","canvasWidth","height","canvasHeight","loadSaveData","saveData","immediateLoading","console","log","Error","parse","push","scaleX","scaleY","scaleAvg","map","line","points","p","brushRadius","curTime","timeoutGap","loadTimeOffset","forEach","brushColor","i","window","setTimeout","drawPoints","length","saveLine","handleTouchStart","e","getPointerPos","lazy","update","both","handleMouseDown","mouseHasMoved","handleTouchMove","preventDefault","handlePointerMove","handleTouchEnd","handleMouseUp","brush","getBrushCoordinates","isPressing","handleMouseMove","isDrawing","handleCanvasResize","entries","observer","entry","contentRect","setCanvasSize","canvas","interface","drawing","temp","drawGrid","loop","once","style","rect","getBoundingClientRect","clientX","clientY","changedTouches","left","top","disabled","hasChanged","isDisabled","isEnabled","toObject","brushHasMoved","lineJoin","lineCap","strokeStyle","clearRect","lineWidth","moveTo","beginPath","len","midPoint","quadraticCurveTo","lineTo","stroke","saveLine2","data","valuesChanged","pointer","getPointerCoordinates","drawInterface","requestAnimationFrame","hideGrid","setLineDash","gridColor","gridSize","countX","countY","fillStyle","arc","Math","PI","fill","catenaryColor","catenary","drawToCanvas","chainLength","radius","lazyRadius","devicePixelRatio","enabled","initialPoint","innerWidth","innerHeight","observe","initX","initY","prevProps","setRadius","className","background","touchAction","container","isInterface","getContext","undefined","propTypes","number","string","bool","defaultProps"],"mappings":";;;;;;;;AAAA,OAAOA,KAAP,IAAgBC,aAAhB,QAAqC,OAArC;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,SAASC,SAAT,QAA0B,YAA1B;AACA,SAASC,QAAT,QAAyB,gBAAzB;AAEA,OAAOC,cAAP,MAA2B,0BAA3B;AAEA,OAAOC,SAAP,MAAsB,aAAtB;;AAEA,SAASC,WAAT,CAAqBC,EAArB,EAAyBC,EAAzB,EAA6B;AAC3B,SAAO;AACLC,IAAAA,CAAC,EAAEF,EAAE,CAACE,CAAH,GAAO,CAACD,EAAE,CAACC,CAAH,GAAOF,EAAE,CAACE,CAAX,IAAgB,CADrB;AAELC,IAAAA,CAAC,EAAEH,EAAE,CAACG,CAAH,GAAO,CAACF,EAAE,CAACE,CAAH,GAAOH,EAAE,CAACG,CAAX,IAAgB;AAFrB,GAAP;AAID;;AAED,IAAMC,WAAW,GAAG;AAClBC,EAAAA,OAAO,EAAE,OADS;AAElBC,EAAAA,QAAQ,EAAE;AAFQ,CAApB;AAKA,IAAMC,WAAW,GAAG,CAClB;AACEC,EAAAA,IAAI,EAAE,WADR;AAEEC,EAAAA,MAAM,EAAE;AAFV,CADkB,EAKlB;AACED,EAAAA,IAAI,EAAE,SADR;AAEEC,EAAAA,MAAM,EAAE;AAFV,CALkB,EASlB;AACED,EAAAA,IAAI,EAAE,MADR;AAEEC,EAAAA,MAAM,EAAE;AAFV,CATkB,EAalB;AACED,EAAAA,IAAI,EAAE,MADR;AAEEC,EAAAA,MAAM,EAAE;AAFV,CAbkB,CAApB;;;;;;;AAoDE,oBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB,kFAAMA,KAAN;;AADiB,UA4EnBC,oBA5EmB,GA4EI,YAAM;AAC3B,YAAKC,cAAL,CAAoBC,SAApB,CAA8B,MAAKC,eAAnC;AACD,KA9EkB;;AAAA,UAgFnBhB,SAhFmB,GAgFP,YAAM;AAChB,UAAI,CAAC,MAAKY,KAAL,CAAWK,MAAhB,EAAwB,OADR,CAGhB;;AACA,YAAKC,KAAL,GAAa,IAAIC,KAAJ,EAAb;AACA,YAAKD,KAAL,CAAWE,GAAX,GAAiB,MAAKR,KAAL,CAAWK,MAA5B,CALgB,CAOhB;;AACA,YAAKC,KAAL,CAAWG,MAAX,GAAoB;AAAA,eAClBrB,SAAS,CAAC;AAAEsB,UAAAA,GAAG,EAAE,MAAKA,GAAL,CAASC,IAAhB;AAAsBC,UAAAA,GAAG,EAAE,MAAKN;AAAhC,SAAD,CADS;AAAA,OAApB;AAED,KA1FkB;;AAAA,UA4FnBO,IA5FmB,GA4FZ,YAAM;AACX,UAAMC,KAAK,GAAG,MAAKA,KAAL,CAAWC,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAd;;AACA,YAAKC,KAAL;;AACA,YAAKC,oBAAL,CAA0B;AAAEH,QAAAA,KAAK,EAALA,KAAF;AAASI,QAAAA,SAAS,EAAE;AAApB,OAA1B;AACD,KAhGkB;;AAAA,UAkGnBC,WAlGmB,GAkGL,YAAM;AAClB;AACA,aAAOC,IAAI,CAACC,SAAL,CAAe;AACpBP,QAAAA,KAAK,EAAE,MAAKA,KADQ;AAEpBQ,QAAAA,KAAK,EAAE,MAAKtB,KAAL,CAAWuB,WAFE;AAGpBC,QAAAA,MAAM,EAAE,MAAKxB,KAAL,CAAWyB;AAHC,OAAf,CAAP;AAKD,KAzGkB;;AAAA,UA2GnBC,YA3GmB,GA2GJ,UAACC,QAAD,EAAuD;AAAA,UAA5CT,SAA4C,uEAAhC,MAAKlB,KAAL,CAAW4B,gBAAqB;AACpEC,MAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BH,QAA1B;;AACA,UAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChC,cAAM,IAAII,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAJmE,wBAMnCX,IAAI,CAACY,KAAL,CAAWL,QAAX,CANmC;AAAA,UAM5Db,KAN4D,eAM5DA,KAN4D;AAAA,UAMrDQ,KANqD,eAMrDA,KANqD;AAAA,UAM9CE,MAN8C,eAM9CA,MAN8C;;AAQpE,UAAI,CAACV,KAAD,IAAU,OAAOA,KAAK,CAACmB,IAAb,KAAsB,UAApC,EAAgD;AAC9C,cAAM,IAAIF,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,YAAKf,KAAL;;AAEA,UACEM,KAAK,KAAK,MAAKtB,KAAL,CAAWuB,WAArB,IACAC,MAAM,KAAK,MAAKxB,KAAL,CAAWyB,YAFxB,EAGE;AACA,cAAKR,oBAAL,CAA0B;AACxBH,UAAAA,KAAK,EAALA,KADwB;AAExBI,UAAAA,SAAS,EAATA;AAFwB,SAA1B;AAID,OARD,MAQO;AACL;AACA,YAAMgB,MAAM,GAAG,MAAKlC,KAAL,CAAWuB,WAAX,GAAyBD,KAAxC;AACA,YAAMa,MAAM,GAAG,MAAKnC,KAAL,CAAWyB,YAAX,GAA0BD,MAAzC;AACA,YAAMY,QAAQ,GAAG,CAACF,MAAM,GAAGC,MAAV,IAAoB,CAArC;;AAEA,cAAKlB,oBAAL,CAA0B;AACxBH,UAAAA,KAAK,EAAEA,KAAK,CAACuB,GAAN,CAAU,UAACC,IAAD;AAAA,qCACZA,IADY;AAEfC,cAAAA,MAAM,EAAED,IAAI,CAACC,MAAL,CAAYF,GAAZ,CAAgB,UAACG,CAAD;AAAA,uBAAQ;AAC9BhD,kBAAAA,CAAC,EAAEgD,CAAC,CAAChD,CAAF,GAAM0C,MADqB;AAE9BzC,kBAAAA,CAAC,EAAE+C,CAAC,CAAC/C,CAAF,GAAM0C;AAFqB,iBAAR;AAAA,eAAhB,CAFO;AAMfM,cAAAA,WAAW,EAAEH,IAAI,CAACG,WAAL,GAAmBL;AANjB;AAAA,WAAV,CADiB;AASxBlB,UAAAA,SAAS,EAATA;AATwB,SAA1B;AAWD;AACF,KAnJkB;;AAAA,UAqJnBD,oBArJmB,GAqJI,gBAA0B;AAAA,UAAvBH,KAAuB,QAAvBA,KAAuB;AAAA,UAAhBI,SAAgB,QAAhBA,SAAgB;AAC/C;AACA;AACA,UAAIwB,OAAO,GAAG,CAAd;AACA,UAAIC,UAAU,GAAGzB,SAAS,GAAG,CAAH,GAAO,MAAKlB,KAAL,CAAW4C,cAA5C;AAEA9B,MAAAA,KAAK,CAAC+B,OAAN,CAAc,UAACP,IAAD,EAAU;AAAA,YACdC,MADc,GACsBD,IADtB,CACdC,MADc;AAAA,YACNO,UADM,GACsBR,IADtB,CACNQ,UADM;AAAA,YACML,WADN,GACsBH,IADtB,CACMG,WADN;;AAAA,mCAGbM,CAHa;AAIpBL,UAAAA,OAAO,IAAIC,UAAX;AACAK,UAAAA,MAAM,CAACC,UAAP,CAAkB,YAAM;AACtB,kBAAKC,UAAL,CAAgB;AACdX,cAAAA,MAAM,EAAEA,MAAM,CAACxB,KAAP,CAAa,CAAb,EAAgBgC,CAAC,GAAG,CAApB,CADM;AAEdD,cAAAA,UAAU,EAAVA,UAFc;AAGdL,cAAAA,WAAW,EAAXA;AAHc,aAAhB;AAKD,WAND,EAMGC,OANH;AALoB;;AAGtB,aAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACY,MAA3B,EAAmCJ,CAAC,EAApC,EAAwC;AAAA,gBAA/BA,CAA+B;AASvC;;AAEDL,QAAAA,OAAO,IAAIC,UAAX;AACAK,QAAAA,MAAM,CAACC,UAAP,CAAkB,YAAM;AACtB;AACA,gBAAKV,MAAL,GAAcA,MAAd;;AACA,gBAAKa,QAAL,CAAc;AAAEN,YAAAA,UAAU,EAAVA,UAAF;AAAcL,YAAAA,WAAW,EAAXA;AAAd,WAAd;AACD,SAJD,EAIGC,OAJH;AAKD,OApBD;AAqBD,KAhLkB;;AAAA,UAkLnBW,gBAlLmB,GAkLA,UAACC,CAAD,EAAO;AAAA,gCACP,MAAKC,aAAL,CAAmBD,CAAnB,CADO;AAAA,UAChB9D,CADgB,uBAChBA,CADgB;AAAA,UACbC,CADa,uBACbA,CADa;;AAExB,YAAK+D,IAAL,CAAUC,MAAV,CAAiB;AAAEjE,QAAAA,CAAC,EAADA,CAAF;AAAKC,QAAAA,CAAC,EAADA;AAAL,OAAjB,EAA2B;AAAEiE,QAAAA,IAAI,EAAE;AAAR,OAA3B;;AACA,YAAKC,eAAL,CAAqBL,CAArB;;AAEA,YAAKM,aAAL,GAAqB,IAArB;AACD,KAxLkB;;AAAA,UA0LnBC,eA1LmB,GA0LD,UAACP,CAAD,EAAO;AACvBA,MAAAA,CAAC,CAACQ,cAAF;;AADuB,iCAEN,MAAKP,aAAL,CAAmBD,CAAnB,CAFM;AAAA,UAEf9D,CAFe,wBAEfA,CAFe;AAAA,UAEZC,CAFY,wBAEZA,CAFY;;AAGvB,YAAKsE,iBAAL,CAAuBvE,CAAvB,EAA0BC,CAA1B;AACD,KA9LkB;;AAAA,UAgMnBuE,cAhMmB,GAgMF,UAACV,CAAD,EAAO;AACtB,YAAKW,aAAL,CAAmBX,CAAnB;;AACA,UAAMY,KAAK,GAAG,MAAKV,IAAL,CAAUW,mBAAV,EAAd;;AACA,YAAKX,IAAL,CAAUC,MAAV,CAAiB;AAAEjE,QAAAA,CAAC,EAAE0E,KAAK,CAAC1E,CAAX;AAAcC,QAAAA,CAAC,EAAEyE,KAAK,CAACzE;AAAvB,OAAjB,EAA6C;AAAEiE,QAAAA,IAAI,EAAE;AAAR,OAA7C;;AACA,YAAKE,aAAL,GAAqB,IAArB;AACD,KArMkB;;AAAA,UAuMnBD,eAvMmB,GAuMD,UAACL,CAAD,EAAO;AACvBA,MAAAA,CAAC,CAACQ,cAAF;AACA,YAAKM,UAAL,GAAkB,IAAlB;AACD,KA1MkB;;AAAA,UA4MnBC,eA5MmB,GA4MD,UAACf,CAAD,EAAO;AAAA,iCACN,MAAKC,aAAL,CAAmBD,CAAnB,CADM;AAAA,UACf9D,CADe,wBACfA,CADe;AAAA,UACZC,CADY,wBACZA,CADY;;AAEvB,YAAKsE,iBAAL,CAAuBvE,CAAvB,EAA0BC,CAA1B;AACD,KA/MkB;;AAAA,UAiNnBwE,aAjNmB,GAiNH,UAACX,CAAD,EAAO;AACrBA,MAAAA,CAAC,CAACQ,cAAF;AACA,YAAKQ,SAAL,GAAiB,KAAjB;AACA,YAAKF,UAAL,GAAkB,KAAlB;;AAEA,YAAKhB,QAAL;AACD,KAvNkB;;AAAA,UAyNnBmB,kBAzNmB,GAyNE,UAACC,OAAD,EAAUC,QAAV,EAAuB;AAC1C,UAAM9C,QAAQ,GAAG,MAAKR,WAAL,EAAjB;;AAD0C;AAAA;AAAA;;AAAA;AAE1C,6BAAoBqD,OAApB,8HAA6B;AAAA,cAAlBE,KAAkB;AAAA,mCACDA,KAAK,CAACC,WADL;AAAA,cACnBrD,KADmB,sBACnBA,KADmB;AAAA,cACZE,MADY,sBACZA,MADY;;AAE3B,gBAAKoD,aAAL,CAAmB,MAAKC,MAAL,CAAYC,SAA/B,EAA0CxD,KAA1C,EAAiDE,MAAjD;;AACA,gBAAKoD,aAAL,CAAmB,MAAKC,MAAL,CAAYE,OAA/B,EAAwCzD,KAAxC,EAA+CE,MAA/C;;AACA,gBAAKoD,aAAL,CAAmB,MAAKC,MAAL,CAAYG,IAA/B,EAAqC1D,KAArC,EAA4CE,MAA5C;;AACA,gBAAKoD,aAAL,CAAmB,MAAKC,MAAL,CAAYlE,IAA/B,EAAqCW,KAArC,EAA4CE,MAA5C;;AAEA,gBAAKyD,QAAL,CAAc,MAAKvE,GAAL,CAASC,IAAvB;;AACA,gBAAKuE,IAAL,CAAU;AAAEC,YAAAA,IAAI,EAAE;AAAR,WAAV;AACD;AAXyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAY1C,YAAKzD,YAAL,CAAkBC,QAAlB,EAA4B,IAA5B;AACD,KAtOkB;;AAAA,UAwOnBiD,aAxOmB,GAwOH,UAACC,MAAD,EAASvD,KAAT,EAAgBE,MAAhB,EAA2B;AACzCqD,MAAAA,MAAM,CAACvD,KAAP,GAAeA,KAAf;AACAuD,MAAAA,MAAM,CAACrD,MAAP,GAAgBA,MAAhB;AACAqD,MAAAA,MAAM,CAACO,KAAP,CAAa9D,KAAb,GAAqBA,KAArB;AACAuD,MAAAA,MAAM,CAACO,KAAP,CAAa5D,MAAb,GAAsBA,MAAtB;AACD,KA7OkB;;AAAA,UA+OnB+B,aA/OmB,GA+OH,UAACD,CAAD,EAAO;AACrB,UAAM+B,IAAI,GAAG,MAAKR,MAAL,CAAYC,SAAZ,CAAsBQ,qBAAtB,EAAb,CADqB,CAGrB;;;AACA,UAAIC,OAAO,GAAGjC,CAAC,CAACiC,OAAhB;AACA,UAAIC,OAAO,GAAGlC,CAAC,CAACkC,OAAhB,CALqB,CAOrB;;AACA,UAAIlC,CAAC,CAACmC,cAAF,IAAoBnC,CAAC,CAACmC,cAAF,CAAiBtC,MAAjB,GAA0B,CAAlD,EAAqD;AACnDoC,QAAAA,OAAO,GAAGjC,CAAC,CAACmC,cAAF,CAAiB,CAAjB,EAAoBF,OAA9B;AACAC,QAAAA,OAAO,GAAGlC,CAAC,CAACmC,cAAF,CAAiB,CAAjB,EAAoBD,OAA9B;AACD,OAXoB,CAarB;;;AACA,aAAO;AACLhG,QAAAA,CAAC,EAAE+F,OAAO,GAAGF,IAAI,CAACK,IADb;AAELjG,QAAAA,CAAC,EAAE+F,OAAO,GAAGH,IAAI,CAACM;AAFb,OAAP;AAID,KAjQkB;;AAAA,UAmQnB5B,iBAnQmB,GAmQC,UAACvE,CAAD,EAAIC,CAAJ,EAAU;AAC5B,UAAI,MAAKO,KAAL,CAAW4F,QAAf,EAAyB;;AAEzB,UAAMC,UAAU,GAAG,MAAKrC,IAAL,CAAUC,MAAV,CAAiB;AAAEjE,QAAAA,CAAC,EAADA,CAAF;AAAKC,QAAAA,CAAC,EAADA;AAAL,OAAjB,CAAnB;;AACA,UAAMqG,UAAU,GAAG,CAAC,MAAKtC,IAAL,CAAUuC,SAAV,EAApB;;AAEA,UACG,MAAK3B,UAAL,IAAmByB,UAAnB,IAAiC,CAAC,MAAKvB,SAAxC,IACCwB,UAAU,IAAI,MAAK1B,UAFtB,EAGE;AACA;AACA,cAAKE,SAAL,GAAiB,IAAjB;;AACA,cAAK/B,MAAL,CAAYN,IAAZ,CAAiB,MAAKuB,IAAL,CAAUU,KAAV,CAAgB8B,QAAhB,EAAjB;AACD;;AAED,UAAI,MAAK1B,SAAL,KAAmB,MAAKd,IAAL,CAAUyC,aAAV,MAA6BH,UAAhD,CAAJ,EAAiE;AAC/D;AACA,cAAKvD,MAAL,CAAYN,IAAZ,CAAiB,MAAKuB,IAAL,CAAUU,KAAV,CAAgB8B,QAAhB,EAAjB,EAF+D,CAI/D;;;AACA,cAAK9C,UAAL,CAAgB;AACdX,UAAAA,MAAM,EAAE,MAAKA,MADC;AAEdO,UAAAA,UAAU,EAAE,MAAK9C,KAAL,CAAW8C,UAFT;AAGdL,UAAAA,WAAW,EAAE,MAAKzC,KAAL,CAAWyC;AAHV,SAAhB;AAKD;;AAED,YAAKmB,aAAL,GAAqB,IAArB;AACD,KA/RkB;;AAAA,UAiSnBV,UAjSmB,GAiSN,iBAAyC;AAAA,UAAtCX,MAAsC,SAAtCA,MAAsC;AAAA,UAA9BO,UAA8B,SAA9BA,UAA8B;AAAA,UAAlBL,WAAkB,SAAlBA,WAAkB;AACpD,YAAK/B,GAAL,CAASsE,IAAT,CAAckB,QAAd,GAAyB,OAAzB;AACA,YAAKxF,GAAL,CAASsE,IAAT,CAAcmB,OAAd,GAAwB,OAAxB;AACA,YAAKzF,GAAL,CAASsE,IAAT,CAAcoB,WAAd,GAA4BtD,UAA5B;;AAEA,YAAKpC,GAAL,CAASsE,IAAT,CAAcqB,SAAd,CACE,CADF,EAEE,CAFF,EAGE,MAAK3F,GAAL,CAASsE,IAAT,CAAcH,MAAd,CAAqBvD,KAHvB,EAIE,MAAKZ,GAAL,CAASsE,IAAT,CAAcH,MAAd,CAAqBrD,MAJvB;;AAMA,YAAKd,GAAL,CAASsE,IAAT,CAAcsB,SAAd,GAA0B7D,WAAW,GAAG,CAAxC;AAEA,UAAInD,EAAE,GAAGiD,MAAM,CAAC,CAAD,CAAf;AACA,UAAIhD,EAAE,GAAGgD,MAAM,CAAC,CAAD,CAAf;;AAEA,YAAK7B,GAAL,CAASsE,IAAT,CAAcuB,MAAd,CAAqBhH,EAAE,CAACC,CAAxB,EAA2BD,EAAE,CAACE,CAA9B;;AACA,YAAKiB,GAAL,CAASsE,IAAT,CAAcwB,SAAd;;AAEA,WAAK,IAAIzD,CAAC,GAAG,CAAR,EAAW0D,GAAG,GAAGlE,MAAM,CAACY,MAA7B,EAAqCJ,CAAC,GAAG0D,GAAzC,EAA8C1D,CAAC,EAA/C,EAAmD;AACjD;AACA;AACA,YAAI2D,QAAQ,GAAGrH,WAAW,CAACC,EAAD,EAAKC,EAAL,CAA1B;;AACA,cAAKmB,GAAL,CAASsE,IAAT,CAAc2B,gBAAd,CAA+BrH,EAAE,CAACE,CAAlC,EAAqCF,EAAE,CAACG,CAAxC,EAA2CiH,QAAQ,CAAClH,CAApD,EAAuDkH,QAAQ,CAACjH,CAAhE;;AACAH,QAAAA,EAAE,GAAGiD,MAAM,CAACQ,CAAD,CAAX;AACAxD,QAAAA,EAAE,GAAGgD,MAAM,CAACQ,CAAC,GAAG,CAAL,CAAX;AACD,OA1BmD,CA2BpD;AACA;AACA;;;AACA,YAAKrC,GAAL,CAASsE,IAAT,CAAc4B,MAAd,CAAqBtH,EAAE,CAACE,CAAxB,EAA2BF,EAAE,CAACG,CAA9B;;AACA,YAAKiB,GAAL,CAASsE,IAAT,CAAc6B,MAAd;AACD,KAjUkB;;AAAA,UAmUnBC,SAnUmB,GAmUP,UAACC,IAAD,EAAU;AACpB,YAAKzC,SAAL,GAAiB,KAAjB;AACA,YAAKF,UAAL,GAAkB,KAAlB;AACAvC,MAAAA,OAAO,CAACC,GAAR,CAAY,sBAAZ,EAAoCiF,IAApC;AACAlF,MAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;;AACA,YAAKhB,KAAL,CAAWmB,IAAX,CAAgB8E,IAAhB;;AACAlF,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuB,MAAKhB,KAA5B;AACA,YAAKyB,MAAL,CAAYY,MAAZ,GAAqB,CAArB;AAEA,UAAM7B,KAAK,GAAG,MAAKuD,MAAL,CAAYG,IAAZ,CAAiB1D,KAA/B;AACA,UAAME,MAAM,GAAG,MAAKqD,MAAL,CAAYG,IAAZ,CAAiBxD,MAAhC,CAVoB,CAYpB;;AACA,YAAKd,GAAL,CAASqE,OAAT,CAAiB3F,SAAjB,CAA2B,MAAKyF,MAAL,CAAYG,IAAvC,EAA6C,CAA7C,EAAgD,CAAhD,EAAmD1D,KAAnD,EAA0DE,MAA1D,EAboB,CAepB;;;AACA,YAAKd,GAAL,CAASsE,IAAT,CAAcqB,SAAd,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B/E,KAA9B,EAAqCE,MAArC;AACD,KApVkB;;AAAA,UAsVnB4B,QAtVmB,GAsVR,YAAsC;AAAA,sFAAP,EAAO;AAAA,UAAnCN,UAAmC,SAAnCA,UAAmC;AAAA,UAAvBL,WAAuB,SAAvBA,WAAuB;;AAC/C,UAAI,MAAKF,MAAL,CAAYY,MAAZ,GAAqB,CAAzB,EAA4B,OADmB,CAG/C;;AACA,YAAKrC,KAAL,CAAWmB,IAAX,CAAgB;AACdM,QAAAA,MAAM,qBAAM,MAAKA,MAAX,CADQ;AAEdO,QAAAA,UAAU,EAAEA,UAAU,IAAI,MAAK9C,KAAL,CAAW8C,UAFvB;AAGdL,QAAAA,WAAW,EAAEA,WAAW,IAAI,MAAKzC,KAAL,CAAWyC;AAHzB,OAAhB,EAJ+C,CAU/C;;;AACA,YAAKF,MAAL,CAAYY,MAAZ,GAAqB,CAArB;AAEA,UAAM7B,KAAK,GAAG,MAAKuD,MAAL,CAAYG,IAAZ,CAAiB1D,KAA/B;AACA,UAAME,MAAM,GAAG,MAAKqD,MAAL,CAAYG,IAAZ,CAAiBxD,MAAhC,CAd+C,CAgB/C;;AACA,YAAKd,GAAL,CAASqE,OAAT,CAAiB3F,SAAjB,CAA2B,MAAKyF,MAAL,CAAYG,IAAvC,EAA6C,CAA7C,EAAgD,CAAhD,EAAmD1D,KAAnD,EAA0DE,MAA1D,EAjB+C,CAmB/C;;;AACA,YAAKd,GAAL,CAASsE,IAAT,CAAcqB,SAAd,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B/E,KAA9B,EAAqCE,MAArC;AACD,KA3WkB;;AAAA,UA6WnBR,KA7WmB,GA6WX,YAAM;AACZ,YAAKF,KAAL,GAAa,EAAb;AACA,YAAKkG,aAAL,GAAqB,IAArB;;AACA,YAAKtG,GAAL,CAASqE,OAAT,CAAiBsB,SAAjB,CACE,CADF,EAEE,CAFF,EAGE,MAAKxB,MAAL,CAAYE,OAAZ,CAAoBzD,KAHtB,EAIE,MAAKuD,MAAL,CAAYE,OAAZ,CAAoBvD,MAJtB;;AAMA,YAAKd,GAAL,CAASsE,IAAT,CAAcqB,SAAd,CACE,CADF,EAEE,CAFF,EAGE,MAAKxB,MAAL,CAAYG,IAAZ,CAAiB1D,KAHnB,EAIE,MAAKuD,MAAL,CAAYG,IAAZ,CAAiBxD,MAJnB;AAMD,KA5XkB;;AAAA,UA8XnB0D,IA9XmB,GA8XZ,YAA2B;AAAA,sFAAP,EAAO;AAAA,6BAAxBC,IAAwB;AAAA,UAAxBA,IAAwB,2BAAjB,KAAiB;;AAChC,UAAI,MAAKvB,aAAL,IAAsB,MAAKoD,aAA/B,EAA8C;AAC5C,YAAMC,OAAO,GAAG,MAAKzD,IAAL,CAAU0D,qBAAV,EAAhB;;AACA,YAAMhD,KAAK,GAAG,MAAKV,IAAL,CAAUW,mBAAV,EAAd;;AAEA,cAAKgD,aAAL,CAAmB,MAAKzG,GAAL,CAASoE,SAA5B,EAAuCmC,OAAvC,EAAgD/C,KAAhD;;AACA,cAAKN,aAAL,GAAqB,KAArB;AACA,cAAKoD,aAAL,GAAqB,KAArB;AACD;;AAED,UAAI,CAAC7B,IAAL,EAAW;AACTnC,QAAAA,MAAM,CAACoE,qBAAP,CAA6B,YAAM;AACjC,gBAAKlC,IAAL;AACD,SAFD;AAGD;AACF,KA7YkB;;AAAA,UA+YnBD,QA/YmB,GA+YR,UAACvE,GAAD,EAAS;AAClB,UAAI,MAAKV,KAAL,CAAWqH,QAAf,EAAyB;AAEzB3G,MAAAA,GAAG,CAAC2F,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB3F,GAAG,CAACmE,MAAJ,CAAWvD,KAA/B,EAAsCZ,GAAG,CAACmE,MAAJ,CAAWrD,MAAjD;AAEAd,MAAAA,GAAG,CAAC8F,SAAJ;AACA9F,MAAAA,GAAG,CAAC4G,WAAJ,CAAgB,CAAC,CAAD,EAAI,CAAJ,CAAhB;AACA5G,MAAAA,GAAG,CAAC4G,WAAJ,CAAgB,EAAhB;AACA5G,MAAAA,GAAG,CAAC0F,WAAJ,GAAkB,MAAKpG,KAAL,CAAWuH,SAA7B;AACA7G,MAAAA,GAAG,CAAC4F,SAAJ,GAAgB,GAAhB;AAEA,UAAMkB,QAAQ,GAAG,EAAjB;AAEA,UAAIC,MAAM,GAAG,CAAb;;AACA,aAAOA,MAAM,GAAG/G,GAAG,CAACmE,MAAJ,CAAWvD,KAA3B,EAAkC;AAChCmG,QAAAA,MAAM,IAAID,QAAV;AACA9G,QAAAA,GAAG,CAAC6F,MAAJ,CAAWkB,MAAX,EAAmB,CAAnB;AACA/G,QAAAA,GAAG,CAACkG,MAAJ,CAAWa,MAAX,EAAmB/G,GAAG,CAACmE,MAAJ,CAAWrD,MAA9B;AACD;;AACDd,MAAAA,GAAG,CAACmG,MAAJ;AAEA,UAAIa,MAAM,GAAG,CAAb;;AACA,aAAOA,MAAM,GAAGhH,GAAG,CAACmE,MAAJ,CAAWrD,MAA3B,EAAmC;AACjCkG,QAAAA,MAAM,IAAIF,QAAV;AACA9G,QAAAA,GAAG,CAAC6F,MAAJ,CAAW,CAAX,EAAcmB,MAAd;AACAhH,QAAAA,GAAG,CAACkG,MAAJ,CAAWlG,GAAG,CAACmE,MAAJ,CAAWvD,KAAtB,EAA6BoG,MAA7B;AACD;;AACDhH,MAAAA,GAAG,CAACmG,MAAJ;AACD,KA3akB;;AAAA,UA6anBM,aA7amB,GA6aH,UAACzG,GAAD,EAAMuG,OAAN,EAAe/C,KAAf,EAAyB;AACvCxD,MAAAA,GAAG,CAAC2F,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB3F,GAAG,CAACmE,MAAJ,CAAWvD,KAA/B,EAAsCZ,GAAG,CAACmE,MAAJ,CAAWrD,MAAjD,EADuC,CAGvC;;AACAd,MAAAA,GAAG,CAAC8F,SAAJ;AACA9F,MAAAA,GAAG,CAACiH,SAAJ,GAAgB,MAAK3H,KAAL,CAAW8C,UAA3B;AACApC,MAAAA,GAAG,CAACkH,GAAJ,CAAQ1D,KAAK,CAAC1E,CAAd,EAAiB0E,KAAK,CAACzE,CAAvB,EAA0B,MAAKO,KAAL,CAAWyC,WAArC,EAAkD,CAAlD,EAAqDoF,IAAI,CAACC,EAAL,GAAU,CAA/D,EAAkE,IAAlE;AACApH,MAAAA,GAAG,CAACqH,IAAJ,GAPuC,CASvC;;AACArH,MAAAA,GAAG,CAAC8F,SAAJ;AACA9F,MAAAA,GAAG,CAACiH,SAAJ,GAAgB,MAAK3H,KAAL,CAAWgI,aAA3B;AACAtH,MAAAA,GAAG,CAACkH,GAAJ,CAAQX,OAAO,CAACzH,CAAhB,EAAmByH,OAAO,CAACxH,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC,EAAoCoI,IAAI,CAACC,EAAL,GAAU,CAA9C,EAAiD,IAAjD;AACApH,MAAAA,GAAG,CAACqH,IAAJ,GAbuC,CAevC;;AACA,UAAI,MAAKvE,IAAL,CAAUuC,SAAV,EAAJ,EAA2B;AACzBrF,QAAAA,GAAG,CAAC8F,SAAJ;AACA9F,QAAAA,GAAG,CAAC4F,SAAJ,GAAgB,CAAhB;AACA5F,QAAAA,GAAG,CAACyF,OAAJ,GAAc,OAAd;AACAzF,QAAAA,GAAG,CAAC4G,WAAJ,CAAgB,CAAC,CAAD,EAAI,CAAJ,CAAhB;AACA5G,QAAAA,GAAG,CAAC0F,WAAJ,GAAkB,MAAKpG,KAAL,CAAWgI,aAA7B;;AACA,cAAKC,QAAL,CAAcC,YAAd,CACE,MAAKxH,GAAL,CAASoE,SADX,EAEEZ,KAFF,EAGE+C,OAHF,EAIE,MAAKkB,WAJP;;AAMAzH,QAAAA,GAAG,CAACmG,MAAJ;AACD,OA7BsC,CA+BvC;;;AACAnG,MAAAA,GAAG,CAAC8F,SAAJ;AACA9F,MAAAA,GAAG,CAACiH,SAAJ,GAAgB,MAAK3H,KAAL,CAAWgI,aAA3B;AACAtH,MAAAA,GAAG,CAACkH,GAAJ,CAAQ1D,KAAK,CAAC1E,CAAd,EAAiB0E,KAAK,CAACzE,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,EAAgCoI,IAAI,CAACC,EAAL,GAAU,CAA1C,EAA6C,IAA7C;AACApH,MAAAA,GAAG,CAACqH,IAAJ;AACD,KAjdkB;;AAGjB,UAAKlD,MAAL,GAAc,EAAd;AACA,UAAKnE,GAAL,GAAW,EAAX;AAEA,UAAKuH,QAAL,GAAgB,IAAI/I,QAAJ,EAAhB;AAEA,UAAKqD,MAAL,GAAc,EAAd;AACA,UAAKzB,KAAL,GAAa,EAAb;AAEA,UAAK8C,aAAL,GAAqB,IAArB;AACA,UAAKoD,aAAL,GAAqB,IAArB;AACA,UAAK1C,SAAL,GAAiB,KAAjB;AACA,UAAKF,UAAL,GAAkB,KAAlB;AAdiB;AAelB;;;;wCAEmB;AAAA;;AAClB,WAAKZ,IAAL,GAAY,IAAIvE,SAAJ,CAAc;AACxBmJ,QAAAA,MAAM,EAAE,KAAKpI,KAAL,CAAWqI,UAAX,GAAwBrF,MAAM,CAACsF,gBADf;AAExBC,QAAAA,OAAO,EAAE,IAFe;AAGxBC,QAAAA,YAAY,EAAE;AACZhJ,UAAAA,CAAC,EAAEwD,MAAM,CAACyF,UAAP,GAAoB,CADX;AAEZhJ,UAAAA,CAAC,EAAEuD,MAAM,CAAC0F,WAAP,GAAqB;AAFZ;AAHU,OAAd,CAAZ;AAQA,WAAKP,WAAL,GAAmB,KAAKnI,KAAL,CAAWqI,UAAX,GAAwBrF,MAAM,CAACsF,gBAAlD;AAEA,WAAKpI,cAAL,GAAsB,IAAIf,cAAJ,CAAmB,UAACqF,OAAD,EAAUC,QAAV;AAAA,eACvC,MAAI,CAACF,kBAAL,CAAwBC,OAAxB,EAAiCC,QAAjC,CADuC;AAAA,OAAnB,CAAtB;AAGA,WAAKvE,cAAL,CAAoByI,OAApB,CAA4B,KAAKvI,eAAjC;AAEA,WAAKhB,SAAL;AACA,WAAK8F,IAAL;AAEAlC,MAAAA,MAAM,CAACC,UAAP,CAAkB,YAAM;AACtB,YAAM2F,KAAK,GAAG5F,MAAM,CAACyF,UAAP,GAAoB,CAAlC;AACA,YAAMI,KAAK,GAAG7F,MAAM,CAAC0F,WAAP,GAAqB,CAAnC;;AACA,QAAA,MAAI,CAAClF,IAAL,CAAUC,MAAV,CACE;AAAEjE,UAAAA,CAAC,EAAEoJ,KAAK,GAAG,MAAI,CAACT,WAAL,GAAmB,CAAhC;AAAmC1I,UAAAA,CAAC,EAAEoJ;AAAtC,SADF,EAEE;AAAEnF,UAAAA,IAAI,EAAE;AAAR,SAFF;;AAIA,QAAA,MAAI,CAACF,IAAL,CAAUC,MAAV,CACE;AAAEjE,UAAAA,CAAC,EAAEoJ,KAAK,GAAG,MAAI,CAACT,WAAL,GAAmB,CAAhC;AAAmC1I,UAAAA,CAAC,EAAEoJ;AAAtC,SADF,EAEE;AAAEnF,UAAAA,IAAI,EAAE;AAAR,SAFF;;AAIA,QAAA,MAAI,CAACE,aAAL,GAAqB,IAArB;AACA,QAAA,MAAI,CAACoD,aAAL,GAAqB,IAArB;;AACA,QAAA,MAAI,CAAChG,KAAL,GAbsB,CAetB;;;AACA,YAAI,MAAI,CAAChB,KAAL,CAAW2B,QAAf,EAAyB;AACvBE,UAAAA,OAAO,CAACC,GAAR;;AACA,UAAA,MAAI,CAACJ,YAAL,CAAkB,MAAI,CAAC1B,KAAL,CAAW2B,QAA7B;AACD;AACF,OApBD,EAoBG,GApBH;AAqBD;;;uCAEkBmH,S,EAAW;AAC5B,UAAIA,SAAS,CAACT,UAAV,KAAyB,KAAKrI,KAAL,CAAWqI,UAAxC,EAAoD;AAClD;AACA,aAAKF,WAAL,GAAmB,KAAKnI,KAAL,CAAWqI,UAAX,GAAwBrF,MAAM,CAACsF,gBAAlD;AACA,aAAK9E,IAAL,CAAUuF,SAAV,CAAoB,KAAK/I,KAAL,CAAWqI,UAAX,GAAwBrF,MAAM,CAACsF,gBAAnD;AACD;;AAED,UAAIQ,SAAS,CAACnH,QAAV,KAAuB,KAAK3B,KAAL,CAAW2B,QAAtC,EAAgD;AAC9C,aAAKD,YAAL,CAAkB,KAAK1B,KAAL,CAAW2B,QAA7B;AACD;;AAED,UAAIP,IAAI,CAACC,SAAL,CAAeyH,SAAf,MAA8B1H,IAAI,CAACC,SAAL,CAAe,KAAKrB,KAApB,CAAlC,EAA8D;AAC5D;AACA,aAAKgH,aAAL,GAAqB,IAArB;AACD;AACF;;;6BAyYQ;AAAA;;AACP,aACE;AACE,QAAA,SAAS,EAAE,KAAKhH,KAAL,CAAWgJ,SADxB;AAEE,QAAA,KAAK;AACHrJ,UAAAA,OAAO,EAAE,OADN;AAEHsJ,UAAAA,UAAU,EAAE,MAFT;AAGHC,UAAAA,WAAW,EAAE,MAHV;AAIH5H,UAAAA,KAAK,EAAE,KAAKtB,KAAL,CAAWuB,WAJf;AAKHC,UAAAA,MAAM,EAAE,KAAKxB,KAAL,CAAWyB;AALhB,WAMA,KAAKzB,KAAL,CAAWoF,KANX,CAFP;AAUE,QAAA,GAAG,EAAE,aAAC+D,SAAD,EAAe;AAClB,cAAIA,SAAJ,EAAe;AACb,YAAA,MAAI,CAAC/I,eAAL,GAAuB+I,SAAvB;AACD;AACF,SAdH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAgBGtJ,WAAW,CAACwC,GAAZ,CAAgB,iBAAsB;AAAA,YAAnBvC,IAAmB,SAAnBA,IAAmB;AAAA,YAAbC,MAAa,SAAbA,MAAa;AACrC,YAAMqJ,WAAW,GAAGtJ,IAAI,KAAK,WAA7B;AACA,eACE;AACE,UAAA,GAAG,EAAEA,IADP;AAEE,UAAA,GAAG,EAAE,aAAC+E,MAAD,EAAY;AACf,gBAAIA,MAAJ,EAAY;AACV,cAAA,MAAI,CAACA,MAAL,CAAY/E,IAAZ,IAAoB+E,MAApB;AACA,cAAA,MAAI,CAACnE,GAAL,CAASZ,IAAT,IAAiB+E,MAAM,CAACwE,UAAP,CAAkB,IAAlB,CAAjB;AACD;AACF,WAPH;AAQE,UAAA,KAAK,oBAAO3J,WAAP;AAAoBK,YAAAA,MAAM,EAANA;AAApB,YARP;AASE,UAAA,WAAW,EAAEqJ,WAAW,GAAG,MAAI,CAACzF,eAAR,GAA0B2F,SATpD;AAUE,UAAA,WAAW,EAAEF,WAAW,GAAG,MAAI,CAAC/E,eAAR,GAA0BiF,SAVpD;AAWE,UAAA,SAAS,EAAEF,WAAW,GAAG,MAAI,CAACnF,aAAR,GAAwBqF,SAXhD;AAYE,UAAA,UAAU,EAAEF,WAAW,GAAG,MAAI,CAACnF,aAAR,GAAwBqF,SAZjD;AAaE,UAAA,YAAY,EAAEF,WAAW,GAAG,MAAI,CAAC/F,gBAAR,GAA2BiG,SAbtD;AAcE,UAAA,WAAW,EAAEF,WAAW,GAAG,MAAI,CAACvF,eAAR,GAA0ByF,SAdpD;AAeE,UAAA,UAAU,EAAEF,WAAW,GAAG,MAAI,CAACpF,cAAR,GAAyBsF,SAflD;AAgBE,UAAA,aAAa,EAAEF,WAAW,GAAG,MAAI,CAACpF,cAAR,GAAyBsF,SAhBrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAoBD,OAtBA,CAhBH,CADF;AA0CD;;;;EA/hB0BvK,a;;SACpBwK,S,GAAY;AACjB3G,EAAAA,cAAc,EAAE5D,SAAS,CAACwK,MADT;AAEjBnB,EAAAA,UAAU,EAAErJ,SAAS,CAACwK,MAFL;AAGjB/G,EAAAA,WAAW,EAAEzD,SAAS,CAACwK,MAHN;AAIjB1G,EAAAA,UAAU,EAAE9D,SAAS,CAACyK,MAJL;AAKjBzB,EAAAA,aAAa,EAAEhJ,SAAS,CAACyK,MALR;AAMjBlC,EAAAA,SAAS,EAAEvI,SAAS,CAACyK,MANJ;AAOjBpC,EAAAA,QAAQ,EAAErI,SAAS,CAAC0K,IAPH;AAQjBnI,EAAAA,WAAW,EAAEvC,SAAS,CAACwK,MARN;AASjB/H,EAAAA,YAAY,EAAEzC,SAAS,CAACwK,MATP;AAUjB5D,EAAAA,QAAQ,EAAE5G,SAAS,CAAC0K,IAVH;AAWjBrJ,EAAAA,MAAM,EAAErB,SAAS,CAACyK,MAXD;AAYjB9H,EAAAA,QAAQ,EAAE3C,SAAS,CAACyK,MAZH;AAajB7H,EAAAA,gBAAgB,EAAE5C,SAAS,CAAC0K;AAbX,C;SAgBZC,Y,GAAe;AACpB/G,EAAAA,cAAc,EAAE,CADI;AAEpByF,EAAAA,UAAU,EAAE,EAFQ;AAGpB5F,EAAAA,WAAW,EAAE,EAHO;AAIpBK,EAAAA,UAAU,EAAE,MAJQ;AAKpBkF,EAAAA,aAAa,EAAE,SALK;AAMpBT,EAAAA,SAAS,EAAE,wBANS;AAOpBF,EAAAA,QAAQ,EAAE,KAPU;AAQpB9F,EAAAA,WAAW,EAAE,GARO;AASpBE,EAAAA,YAAY,EAAE,GATM;AAUpBmE,EAAAA,QAAQ,EAAE,KAVU;AAWpBvF,EAAAA,MAAM,EAAE,EAXY;AAYpBsB,EAAAA,QAAQ,EAAE,EAZU;AAapBC,EAAAA,gBAAgB,EAAE;AAbE,C","sourcesContent":["import React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { LazyBrush } from \"lazy-brush\";\nimport { Catenary } from \"catenary-curve\";\n\nimport ResizeObserver from \"resize-observer-polyfill\";\n\nimport drawImage from \"./drawImage\";\n\nfunction midPointBtw(p1, p2) {\n  return {\n    x: p1.x + (p2.x - p1.x) / 2,\n    y: p1.y + (p2.y - p1.y) / 2,\n  };\n}\n\nconst canvasStyle = {\n  display: \"block\",\n  position: \"absolute\",\n};\n\nconst canvasTypes = [\n  {\n    name: \"interface\",\n    zIndex: 15,\n  },\n  {\n    name: \"drawing\",\n    zIndex: 11,\n  },\n  {\n    name: \"temp\",\n    zIndex: 12,\n  },\n  {\n    name: \"grid\",\n    zIndex: 10,\n  },\n];\n\nexport default class extends PureComponent {\n  static propTypes = {\n    loadTimeOffset: PropTypes.number,\n    lazyRadius: PropTypes.number,\n    brushRadius: PropTypes.number,\n    brushColor: PropTypes.string,\n    catenaryColor: PropTypes.string,\n    gridColor: PropTypes.string,\n    hideGrid: PropTypes.bool,\n    canvasWidth: PropTypes.number,\n    canvasHeight: PropTypes.number,\n    disabled: PropTypes.bool,\n    imgSrc: PropTypes.string,\n    saveData: PropTypes.string,\n    immediateLoading: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    loadTimeOffset: 5,\n    lazyRadius: 12,\n    brushRadius: 10,\n    brushColor: \"#444\",\n    catenaryColor: \"#0a0302\",\n    gridColor: \"rgba(150,150,150,0.17)\",\n    hideGrid: false,\n    canvasWidth: 400,\n    canvasHeight: 400,\n    disabled: false,\n    imgSrc: \"\",\n    saveData: \"\",\n    immediateLoading: false,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.canvas = {};\n    this.ctx = {};\n\n    this.catenary = new Catenary();\n\n    this.points = [];\n    this.lines = [];\n\n    this.mouseHasMoved = true;\n    this.valuesChanged = true;\n    this.isDrawing = false;\n    this.isPressing = false;\n  }\n\n  componentDidMount() {\n    this.lazy = new LazyBrush({\n      radius: this.props.lazyRadius * window.devicePixelRatio,\n      enabled: true,\n      initialPoint: {\n        x: window.innerWidth / 2,\n        y: window.innerHeight / 2,\n      },\n    });\n    this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n\n    this.canvasObserver = new ResizeObserver((entries, observer) =>\n      this.handleCanvasResize(entries, observer)\n    );\n    this.canvasObserver.observe(this.canvasContainer);\n\n    this.drawImage();\n    this.loop();\n\n    window.setTimeout(() => {\n      const initX = window.innerWidth / 2;\n      const initY = window.innerHeight / 2;\n      this.lazy.update(\n        { x: initX - this.chainLength / 4, y: initY },\n        { both: true }\n      );\n      this.lazy.update(\n        { x: initX + this.chainLength / 4, y: initY },\n        { both: false }\n      );\n      this.mouseHasMoved = true;\n      this.valuesChanged = true;\n      this.clear();\n\n      // Load saveData from prop if it exists\n      if (this.props.saveData) {\n        console.log;\n        this.loadSaveData(this.props.saveData);\n      }\n    }, 100);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.lazyRadius !== this.props.lazyRadius) {\n      // Set new lazyRadius values\n      this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n      this.lazy.setRadius(this.props.lazyRadius * window.devicePixelRatio);\n    }\n\n    if (prevProps.saveData !== this.props.saveData) {\n      this.loadSaveData(this.props.saveData);\n    }\n\n    if (JSON.stringify(prevProps) !== JSON.stringify(this.props)) {\n      // Signal this.loop function that values changed\n      this.valuesChanged = true;\n    }\n  }\n\n  componentWillUnmount = () => {\n    this.canvasObserver.unobserve(this.canvasContainer);\n  };\n\n  drawImage = () => {\n    if (!this.props.imgSrc) return;\n\n    // Load the image\n    this.image = new Image();\n    this.image.src = this.props.imgSrc;\n\n    // Draw the image once loaded\n    this.image.onload = () =>\n      drawImage({ ctx: this.ctx.grid, img: this.image });\n  };\n\n  undo = () => {\n    const lines = this.lines.slice(0, -1);\n    this.clear();\n    this.simulateDrawingLines({ lines, immediate: true });\n  };\n\n  getSaveData = () => {\n    // Construct and return the stringified saveData object\n    return JSON.stringify({\n      lines: this.lines,\n      width: this.props.canvasWidth,\n      height: this.props.canvasHeight,\n    });\n  };\n\n  loadSaveData = (saveData, immediate = this.props.immediateLoading) => {\n    console.log(\"save data \", saveData);\n    if (typeof saveData !== \"string\") {\n      throw new Error(\"saveData needs to be of type string!\");\n    }\n\n    const { lines, width, height } = JSON.parse(saveData);\n\n    if (!lines || typeof lines.push !== \"function\") {\n      throw new Error(\"saveData.lines needs to be an array!\");\n    }\n\n    this.clear();\n\n    if (\n      width === this.props.canvasWidth &&\n      height === this.props.canvasHeight\n    ) {\n      this.simulateDrawingLines({\n        lines,\n        immediate,\n      });\n    } else {\n      // we need to rescale the lines based on saved & current dimensions\n      const scaleX = this.props.canvasWidth / width;\n      const scaleY = this.props.canvasHeight / height;\n      const scaleAvg = (scaleX + scaleY) / 2;\n\n      this.simulateDrawingLines({\n        lines: lines.map((line) => ({\n          ...line,\n          points: line.points.map((p) => ({\n            x: p.x * scaleX,\n            y: p.y * scaleY,\n          })),\n          brushRadius: line.brushRadius * scaleAvg,\n        })),\n        immediate,\n      });\n    }\n  };\n\n  simulateDrawingLines = ({ lines, immediate }) => {\n    // Simulate live-drawing of the loaded lines\n    // TODO use a generator\n    let curTime = 0;\n    let timeoutGap = immediate ? 0 : this.props.loadTimeOffset;\n\n    lines.forEach((line) => {\n      const { points, brushColor, brushRadius } = line;\n\n      for (let i = 1; i < points.length; i++) {\n        curTime += timeoutGap;\n        window.setTimeout(() => {\n          this.drawPoints({\n            points: points.slice(0, i + 1),\n            brushColor,\n            brushRadius,\n          });\n        }, curTime);\n      }\n\n      curTime += timeoutGap;\n      window.setTimeout(() => {\n        // Save this line with its props instead of this.props\n        this.points = points;\n        this.saveLine({ brushColor, brushRadius });\n      }, curTime);\n    });\n  };\n\n  handleTouchStart = (e) => {\n    const { x, y } = this.getPointerPos(e);\n    this.lazy.update({ x, y }, { both: true });\n    this.handleMouseDown(e);\n\n    this.mouseHasMoved = true;\n  };\n\n  handleTouchMove = (e) => {\n    e.preventDefault();\n    const { x, y } = this.getPointerPos(e);\n    this.handlePointerMove(x, y);\n  };\n\n  handleTouchEnd = (e) => {\n    this.handleMouseUp(e);\n    const brush = this.lazy.getBrushCoordinates();\n    this.lazy.update({ x: brush.x, y: brush.y }, { both: true });\n    this.mouseHasMoved = true;\n  };\n\n  handleMouseDown = (e) => {\n    e.preventDefault();\n    this.isPressing = true;\n  };\n\n  handleMouseMove = (e) => {\n    const { x, y } = this.getPointerPos(e);\n    this.handlePointerMove(x, y);\n  };\n\n  handleMouseUp = (e) => {\n    e.preventDefault();\n    this.isDrawing = false;\n    this.isPressing = false;\n\n    this.saveLine();\n  };\n\n  handleCanvasResize = (entries, observer) => {\n    const saveData = this.getSaveData();\n    for (const entry of entries) {\n      const { width, height } = entry.contentRect;\n      this.setCanvasSize(this.canvas.interface, width, height);\n      this.setCanvasSize(this.canvas.drawing, width, height);\n      this.setCanvasSize(this.canvas.temp, width, height);\n      this.setCanvasSize(this.canvas.grid, width, height);\n\n      this.drawGrid(this.ctx.grid);\n      this.loop({ once: true });\n    }\n    this.loadSaveData(saveData, true);\n  };\n\n  setCanvasSize = (canvas, width, height) => {\n    canvas.width = width;\n    canvas.height = height;\n    canvas.style.width = width;\n    canvas.style.height = height;\n  };\n\n  getPointerPos = (e) => {\n    const rect = this.canvas.interface.getBoundingClientRect();\n\n    // use cursor pos as default\n    let clientX = e.clientX;\n    let clientY = e.clientY;\n\n    // use first touch if available\n    if (e.changedTouches && e.changedTouches.length > 0) {\n      clientX = e.changedTouches[0].clientX;\n      clientY = e.changedTouches[0].clientY;\n    }\n\n    // return mouse/touch position inside canvas\n    return {\n      x: clientX - rect.left,\n      y: clientY - rect.top,\n    };\n  };\n\n  handlePointerMove = (x, y) => {\n    if (this.props.disabled) return;\n\n    const hasChanged = this.lazy.update({ x, y });\n    const isDisabled = !this.lazy.isEnabled();\n\n    if (\n      (this.isPressing && hasChanged && !this.isDrawing) ||\n      (isDisabled && this.isPressing)\n    ) {\n      // Start drawing and add point\n      this.isDrawing = true;\n      this.points.push(this.lazy.brush.toObject());\n    }\n\n    if (this.isDrawing && (this.lazy.brushHasMoved() || isDisabled)) {\n      // Add new point\n      this.points.push(this.lazy.brush.toObject());\n\n      // Draw current points\n      this.drawPoints({\n        points: this.points,\n        brushColor: this.props.brushColor,\n        brushRadius: this.props.brushRadius,\n      });\n    }\n\n    this.mouseHasMoved = true;\n  };\n\n  drawPoints = ({ points, brushColor, brushRadius }) => {\n    this.ctx.temp.lineJoin = \"round\";\n    this.ctx.temp.lineCap = \"round\";\n    this.ctx.temp.strokeStyle = brushColor;\n\n    this.ctx.temp.clearRect(\n      0,\n      0,\n      this.ctx.temp.canvas.width,\n      this.ctx.temp.canvas.height\n    );\n    this.ctx.temp.lineWidth = brushRadius * 2;\n\n    let p1 = points[0];\n    let p2 = points[1];\n\n    this.ctx.temp.moveTo(p2.x, p2.y);\n    this.ctx.temp.beginPath();\n\n    for (var i = 1, len = points.length; i < len; i++) {\n      // we pick the point between pi+1 & pi+2 as the\n      // end point and p1 as our control point\n      var midPoint = midPointBtw(p1, p2);\n      this.ctx.temp.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n      p1 = points[i];\n      p2 = points[i + 1];\n    }\n    // Draw last line as a straight line while\n    // we wait for the next point to be able to calculate\n    // the bezier control point\n    this.ctx.temp.lineTo(p1.x, p1.y);\n    this.ctx.temp.stroke();\n  };\n\n  saveLine2 = (data) => {\n    this.isDrawing = false;\n    this.isPressing = false;\n    console.log(\"data from saveline: \", data);\n    console.log(\"saveLine2 called\");\n    this.lines.push(data);\n    console.log(\"lines: \", this.lines);\n    this.points.length = 0;\n\n    const width = this.canvas.temp.width;\n    const height = this.canvas.temp.height;\n\n    // Copy the line to the drawing canvas\n    this.ctx.drawing.drawImage(this.canvas.temp, 0, 0, width, height);\n\n    // Clear the temporary line-drawing canvas\n    this.ctx.temp.clearRect(0, 0, width, height);\n  };\n\n  saveLine = ({ brushColor, brushRadius } = {}) => {\n    if (this.points.length < 2) return;\n\n    // Save as new line\n    this.lines.push({\n      points: [...this.points],\n      brushColor: brushColor || this.props.brushColor,\n      brushRadius: brushRadius || this.props.brushRadius,\n    });\n\n    // Reset points array\n    this.points.length = 0;\n\n    const width = this.canvas.temp.width;\n    const height = this.canvas.temp.height;\n\n    // Copy the line to the drawing canvas\n    this.ctx.drawing.drawImage(this.canvas.temp, 0, 0, width, height);\n\n    // Clear the temporary line-drawing canvas\n    this.ctx.temp.clearRect(0, 0, width, height);\n  };\n\n  clear = () => {\n    this.lines = [];\n    this.valuesChanged = true;\n    this.ctx.drawing.clearRect(\n      0,\n      0,\n      this.canvas.drawing.width,\n      this.canvas.drawing.height\n    );\n    this.ctx.temp.clearRect(\n      0,\n      0,\n      this.canvas.temp.width,\n      this.canvas.temp.height\n    );\n  };\n\n  loop = ({ once = false } = {}) => {\n    if (this.mouseHasMoved || this.valuesChanged) {\n      const pointer = this.lazy.getPointerCoordinates();\n      const brush = this.lazy.getBrushCoordinates();\n\n      this.drawInterface(this.ctx.interface, pointer, brush);\n      this.mouseHasMoved = false;\n      this.valuesChanged = false;\n    }\n\n    if (!once) {\n      window.requestAnimationFrame(() => {\n        this.loop();\n      });\n    }\n  };\n\n  drawGrid = (ctx) => {\n    if (this.props.hideGrid) return;\n\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    ctx.beginPath();\n    ctx.setLineDash([5, 1]);\n    ctx.setLineDash([]);\n    ctx.strokeStyle = this.props.gridColor;\n    ctx.lineWidth = 0.5;\n\n    const gridSize = 25;\n\n    let countX = 0;\n    while (countX < ctx.canvas.width) {\n      countX += gridSize;\n      ctx.moveTo(countX, 0);\n      ctx.lineTo(countX, ctx.canvas.height);\n    }\n    ctx.stroke();\n\n    let countY = 0;\n    while (countY < ctx.canvas.height) {\n      countY += gridSize;\n      ctx.moveTo(0, countY);\n      ctx.lineTo(ctx.canvas.width, countY);\n    }\n    ctx.stroke();\n  };\n\n  drawInterface = (ctx, pointer, brush) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Draw brush preview\n    ctx.beginPath();\n    ctx.fillStyle = this.props.brushColor;\n    ctx.arc(brush.x, brush.y, this.props.brushRadius, 0, Math.PI * 2, true);\n    ctx.fill();\n\n    // Draw mouse point (the one directly at the cursor)\n    ctx.beginPath();\n    ctx.fillStyle = this.props.catenaryColor;\n    ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI * 2, true);\n    ctx.fill();\n\n    // Draw catenary\n    if (this.lazy.isEnabled()) {\n      ctx.beginPath();\n      ctx.lineWidth = 2;\n      ctx.lineCap = \"round\";\n      ctx.setLineDash([2, 4]);\n      ctx.strokeStyle = this.props.catenaryColor;\n      this.catenary.drawToCanvas(\n        this.ctx.interface,\n        brush,\n        pointer,\n        this.chainLength\n      );\n      ctx.stroke();\n    }\n\n    // Draw brush point (the one in the middle of the brush preview)\n    ctx.beginPath();\n    ctx.fillStyle = this.props.catenaryColor;\n    ctx.arc(brush.x, brush.y, 2, 0, Math.PI * 2, true);\n    ctx.fill();\n  };\n\n  render() {\n    return (\n      <div\n        className={this.props.className}\n        style={{\n          display: \"block\",\n          background: \"#fff\",\n          touchAction: \"none\",\n          width: this.props.canvasWidth,\n          height: this.props.canvasHeight,\n          ...this.props.style,\n        }}\n        ref={(container) => {\n          if (container) {\n            this.canvasContainer = container;\n          }\n        }}\n      >\n        {canvasTypes.map(({ name, zIndex }) => {\n          const isInterface = name === \"interface\";\n          return (\n            <canvas\n              key={name}\n              ref={(canvas) => {\n                if (canvas) {\n                  this.canvas[name] = canvas;\n                  this.ctx[name] = canvas.getContext(\"2d\");\n                }\n              }}\n              style={{ ...canvasStyle, zIndex }}\n              onMouseDown={isInterface ? this.handleMouseDown : undefined}\n              onMouseMove={isInterface ? this.handleMouseMove : undefined}\n              onMouseUp={isInterface ? this.handleMouseUp : undefined}\n              onMouseOut={isInterface ? this.handleMouseUp : undefined}\n              onTouchStart={isInterface ? this.handleTouchStart : undefined}\n              onTouchMove={isInterface ? this.handleTouchMove : undefined}\n              onTouchEnd={isInterface ? this.handleTouchEnd : undefined}\n              onTouchCancel={isInterface ? this.handleTouchEnd : undefined}\n            />\n          );\n        })}\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}